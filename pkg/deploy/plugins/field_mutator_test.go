package plugins

import (
	"maps"
	"testing"

	"github.com/stretchr/testify/require"
	"sigs.k8s.io/kustomize/api/resmap"
	"sigs.k8s.io/kustomize/api/resource"
)

func TestIsEmpty(t *testing.T) {
	testCases := []struct {
		name     string
		input    any
		expected bool
	}{
		{
			name:     "nil value",
			input:    nil,
			expected: true,
		},
		{
			name:     "empty string",
			input:    "",
			expected: true,
		},
		{
			name:     "non-empty string",
			input:    "hello",
			expected: false,
		},
		{
			name:     "empty map",
			input:    make(map[string]any),
			expected: true,
		},
		{
			name:     "non-empty map",
			input:    map[string]any{"key": "value"},
			expected: false,
		},
		{
			name:     "empty slice",
			input:    make([]any, 0),
			expected: true,
		},
		{
			name:     "non-empty slice",
			input:    []any{1, 2},
			expected: false,
		},
		{
			name:     "zero value integer",
			input:    0,
			expected: false,
		},
		{
			name:     "zero value boolean",
			input:    false,
			expected: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			actual := isEmpty(tc.input)
			require.Equal(t, tc.expected, actual)
		})
	}
}

// TestSetTargetField covers the core mechanics of the un-exported helper function.
func TestSetTargetField(t *testing.T) {
	// add test cases for setting complex map, and slice values.
	testCases := []struct {
		name          string
		initialSpec   map[string]any
		mapping       FieldMapping
		value         any
		expectedSpec  map[string]any
		expectError   bool
		errorContains string
	}{
		{
			name:         "overwrite existing value",
			initialSpec:  map[string]any{"replicas": 1},
			mapping:      FieldMapping{TargetField: "spec.replicas"},
			value:        3,
			expectedSpec: map[string]any{"replicas": 3},
		},
		{
			name:        "create nested path that does not exist",
			initialSpec: map[string]any{},
			mapping: FieldMapping{
				TargetField:       "spec.strategy.type",
				CreateIfNotExists: true,
			},
			value:        "Recreate",
			expectedSpec: map[string]any{"strategy": map[string]any{"type": "Recreate"}},
		},
		{
			name:          "fail when path does not exist and CreateIfNotExists is false",
			initialSpec:   map[string]any{},
			mapping:       FieldMapping{TargetField: "spec.strategy.type"},
			value:         "Recreate",
			expectError:   true,
			errorContains: "failed to find field strategy",
		},
		{
			name:          "fail when intermediate path is not a map",
			initialSpec:   map[string]any{"replicas": 1},
			mapping:       FieldMapping{TargetField: "spec.replicas.count"},
			value:         1,
			expectError:   true,
			errorContains: "failed to convert field replicas to map",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// newTestResource creates a full Kubernetes object which then gets transformed.
			// The internal 'setTargetField' function works with a resource.Resource.
			// The initialSpec is passed as 'content' for the Pod.
			res := newTestResource(t, "v1", "Pod", "test-pod", "dummy", tc.initialSpec)
			err := setTargetField(res, tc.value, tc.mapping)

			if tc.expectError {
				require.Error(t, err)
				require.Contains(t, err.Error(), tc.errorContains)
			} else {
				require.NoError(t, err)
				finalMap, err := res.Map()
				require.NoError(t, err)
				require.Equal(t, tc.expectedSpec, finalMap["spec"]) // Compare the 'spec' field of the transformed resource
			}
		})
	}
}

// TestTransform covers the public API's orchestration logic.
func TestTransform(t *testing.T) {
	// Define the common base spec generated by newTestResource for Deployment objects.
	// This helps in creating expected output maps accurately.
	expectedDeploymentBaseContent := map[string]any{
		"selector": map[string]any{
			"matchLabels": map[string]any{"app": "my-deploy"},
		},
		"template": map[string]any{
			"metadata": map[string]any{"labels": map[string]any{"app": "my-deploy"}},
			"spec": map[string]any{
				"containers": []any{
					map[string]any{"name": "test-container", "image": "nginx"},
				},
			},
		},
	}

	testCases := []struct {
		name             string
		transformer      *fieldMutator
		initialResources []*resource.Resource
		expectedSpecs    map[string]map[string]any // map[resource-name]expected-spec
		expectError      bool
	}{
		{
			name: "apply mapping to correct resource kind",
			transformer: CreateFieldMutator(FieldMutatorConfig{
				Mappings: []FieldMapping{
					{TargetKind: "Deployment", TargetField: "spec.replicas", SourceValue: 5},
				},
			}),
			initialResources: []*resource.Resource{
				// Provide content for newTestResource to generate a Deployment
				newTestResource(t, "apps/v1", "Deployment", "my-deploy", "", map[string]any{"replicas": 1}),
				newTestResource(t, "v1", "Service", "my-service", "", map[string]any{}),
			},
			expectedSpecs: map[string]map[string]any{
				"my-deploy": func() map[string]any {
					// Deep copy the base content and add/modify replicas
					s := make(map[string]any)
					maps.Copy(s, expectedDeploymentBaseContent)
					s["replicas"] = 5
					return s
				}(),
				"my-service": {}, // Service spec remains empty
			},
		},
		{
			name: "use default value when source is empty",
			transformer: CreateFieldMutator(FieldMutatorConfig{
				Mappings: []FieldMapping{
					{TargetKind: "Deployment", TargetField: "spec.replicas", SourceValue: nil, DefaultValue: 3},
				},
			}),
			initialResources: []*resource.Resource{
				newTestResource(t, "apps/v1", "Deployment", "my-deploy", "", map[string]any{"replicas": 1}),
			},
			expectedSpecs: map[string]map[string]any{
				"my-deploy": func() map[string]any {
					// Deep copy the base content and add/modify replicas
					s := make(map[string]any)
					maps.Copy(s, expectedDeploymentBaseContent)
					s["replicas"] = 3
					return s
				}(),
			},
		},
		{
			name: "propagate error from helper",
			transformer: CreateFieldMutator(FieldMutatorConfig{
				Mappings: []FieldMapping{
					{TargetKind: "Deployment", TargetField: "spec.replicas.invalid", SourceValue: 1},
				},
			}),
			initialResources: []*resource.Resource{
				newTestResource(t, "apps/v1", "Deployment", "my-deploy", "", map[string]any{"replicas": 1}),
			},
			expectError: true,
		},
		{
			name: "array index support integration",
			transformer: CreateFieldMutator(FieldMutatorConfig{
				Mappings: []FieldMapping{
					{TargetKind: "Service", TargetField: "spec.ports[0].port", SourceValue: 8080, CreateIfNotExists: true},
					{TargetKind: "Service", TargetField: "spec.ports[0].targetPort", SourceValue: 8080, CreateIfNotExists: true},
				},
			}),
			initialResources: []*resource.Resource{
				newTestResource(t, "v1", "Service", "my-service", "", map[string]any{
					"ports": []any{
						map[string]any{"port": 80, "name": "http"},
					},
				}),
			},
			expectedSpecs: map[string]map[string]any{
				"my-service": {
					"ports": []any{
						map[string]any{"port": 8080, "targetPort": 8080, "name": "http"},
					},
				},
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			resMap := resmap.New()
			for _, res := range tc.initialResources {
				err := resMap.Append(res)
				require.NoError(t, err)
			}

			err := tc.transformer.Transform(resMap)

			if tc.expectError {
				require.Error(t, err)
			} else {
				require.NoError(t, err)
				for _, res := range resMap.Resources() {
					expectedSpec := tc.expectedSpecs[res.GetName()]
					finalMap, err := res.Map()
					require.NoError(t, err)
					// Compare the 'spec' field of the transformed resource
					require.Equal(t, expectedSpec, finalMap["spec"])
				}
			}
		})
	}
}
